
<html>
<head>
<title>TP1 Partie1 Anis Benyoub</title>
<!-- Import de la lib de math glMatrix -->
<!-- Cette librarie provient de https://code.google.com/p/glmatrix/ -->
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="libtp2.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<!-- Declaration du fragment shader -->
<script id="basicFragment" type="glsl/frag">
    // Declaration de la précision des flottants
    precision mediump float;
    // Attributs interpolés par la pipeline WebGL
    // Normale normalisée en espace monde
    varying vec3 normal;
    // Coordonnées de textures pour la sphere
    varying vec2 texcoord;
    // Direction de la lumière en coordonnées monde
    varying vec3 light;
    // Réfléctance de l'objet
    uniform vec3 rho;
    // Intensité lumineuse de la source de lumière
    uniform float I;

    void main(void) 
    {

        // Calcul de la lumière
        gl_FragColor = vec4(I*rho*dot(normal,light),1.0);
    }
</script>

<!-- Declaration du vertex shader -->
<script id="basicVertex" type="glsl/vertex">
    //Attributs passés en attribute
    // Position du vertex en espace objet
    attribute vec3 VertexPosition;
    // Normale du vertex en espace objet
    attribute vec3 VertexNormal;
    // Coordonnées textures pour le vertex
    attribute vec2 VertexTexCoord;

    // Matrice de projection    
    uniform mat4 ProjMatrix;
    // Matrice de vue
    uniform mat4 ViewMatrix;
    // Matrice de modele
    uniform mat4 ModelMatrix;
    // Matrice normale (Inverse de la matrice de modèle pour les normales)
    uniform mat4 NormalMatrix;
    // Direction de la lumière en espace monde
    uniform vec3 LightDirection;


    // Données à Injecter dans le fragment shader
    // Normale normalisée en espace monde
    varying vec3 normal;
    // Vecteur lumière en espace monde
    varying vec3 light;
    varying float distance;
    // Coordnnées texture
    varying vec2 texcoord;
    const mat4 ScaleMatrix = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);
    void main(void) 
    {
        // Conversion en coordnnées clipping
        vec4 ecPos = ModelMatrix * vec4(VertexPosition, 1.0);
        gl_Position = ProjMatrix * ViewMatrix * ecPos;
        // Normalisation du vecteur de lumière (peut être fait dans le CPU pour éviter de le refaire)
        light = (LightDirection-ecPos.xyz);
        light=normalize(light);
        // Normalisation et conversion en espace monde
        normal = normalize(NormalMatrix*vec4(VertexNormal,0.0)).xyz;
        // coordonnées de texture
        texcoord = VertexTexCoord;
    }
</script>

<script type="text/javascript">

    // Variables gobales
    var gl;
    var canvas;

    var delta = 0.0;
    // Inputs
    var currentlyPressedKeys = {};
    // Camera 
    var camera = [];
    // Données sphères
    var sceneObjects = [];
    var pointLight = [];
    var isRendering = false;


    function initCamera()
    {
        camera.projectionMatrix = mat4.create();
        // On définie la matrice de projection
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, camera.projectionMatrix);
        // On définie la matrice de vue
        camera.viewMatrix = mat4.create();
        mat4.identity(camera.viewMatrix);
        mat4.translate(camera.viewMatrix, [0,0,-300]);


        camera.isOutDated =  true;
    }

    function initShaderData(parProgram, parObj)
    {

        // On bind le vertex buffer object de position
        parProgram.vertexPositionAttribute = gl.getAttribLocation(parProgram, "VertexPosition");
        
        // On bind le vertex buffer object de normale
        parProgram.vertexNormalAttribute = gl.getAttribLocation(parProgram, "VertexNormal");

        // On bind le vertex buffer object de tex coord
        parProgram.vertexTexCoordAttribute = gl.getAttribLocation(parProgram, "VertexTexCoord");

        // On récupère l'index la matrice de projection
        parProgram.projMatrix = gl.getUniformLocation(parProgram, "ProjMatrix");
        // On récupère l'index la matrice de vue
        parProgram.viewMatrix = gl.getUniformLocation(parProgram, "ViewMatrix");
        // On récupère l'index de la normal matrix
        parProgram.normalMatrix = gl.getUniformLocation(parProgram, "NormalMatrix");

        // On récupère l'index la matrice de modele
        parProgram.modelMatrix = gl.getUniformLocation(parProgram, "ModelMatrix");

        // On récupère l'index de la reflectance
        parProgram.colorUniform = gl.getUniformLocation(parProgram, "rho");
        // On récupère l'index de la variable uniform d'intensité
        parProgram.lightIntensity = gl.getUniformLocation(parProgram, "I");
        // On récupère l'index de la variable uniform de direction lumière
        parProgram.lightDirection = gl.getUniformLocation(parProgram, "LightDirection");

        // Injection de la projection matrix
        gl.uniformMatrix4fv(parProgram.projMatrix, false, camera.projectionMatrix);

        //Injection de s données de réfléctance
        gl.uniform3fv(parProgram.colorUniform, parObj.colorVal);

        // Injection des données de lumières
        gl.uniform1f(parProgram.lightIntensity, 3.14*2.0);     
    }

    function injectGenericUniforms(parShader)
    {

        if(camera.isOutDated)
        {  
            // Injection de la view matrix
            gl.uniformMatrix4fv(parShader.viewMatrix, false, camera.viewMatrix);

        }
    }

    function injectSpecificUniforms(parObj) 
    {
        if(parObj.isOutDated)
        {
            //Injection de la model matrix
            gl.uniformMatrix4fv(parObj.shaderProgram.modelMatrix, false, parObj.modelMatrix);
            parObj.isOutDated = false;

            // Injection de la normal matrix
            var normalMatrix = mat4.create();
            mat4.inverse(parObj.modelMatrix,normalMatrix);
            gl.uniformMatrix4fv(parObj.shaderProgram.normalMatrix, false, normalMatrix);
        }

        gl.uniformMatrix4fv(parObj.shaderProgram.lightProjMatrix, false, pointLight.projectionMatrix);


    }

    // Inspiré de l'implémentation de 
    // http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere
    function createSphere(parRadius, parPosition, parColorVal, parTesselation)
    {
        // Données de sphere
        var sphere = [];
        // Données  attribute
        var vertexPositionData = [];
        var normalData = [];
        var textureCoordData = [];

        // Pour chacun des somemts
        for (var latNumber = 0; latNumber <= parTesselation; latNumber++) 
        {
            var theta = latNumber * Math.PI / parTesselation;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            for (var longNumber = 0; longNumber <= parTesselation; longNumber++) 
            {
                var phi = longNumber * 2 * Math.PI / parTesselation;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);
                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1- (longNumber / parTesselation);
                var v = latNumber / parTesselation;
                // Si la sphère est gérée de manière interne (necessité d'éclairage)
                normalData.push(x);
                normalData.push(y);
                normalData.push(z);                   
                // données de texture
                textureCoordData.push(u);
                textureCoordData.push(v);
                // Donnée de positrion
                vertexPositionData.push(parRadius * x);
                vertexPositionData.push(parRadius * y);
                vertexPositionData.push(parRadius * z);
            }
        }
        // Tableau d'indexes
        var indexData = [];
        for (var latNumber = 0; latNumber < parTesselation; latNumber++) 
        {
            for (var longNumber = 0; longNumber < parTesselation; longNumber++) 
            {
                var first = (latNumber * (parTesselation + 1)) + longNumber;
                var second = first + parTesselation + 1;
                indexData.push(first);
                indexData.push(second);
                indexData.push(first + 1);
                indexData.push(second);
                indexData.push(second + 1);
                indexData.push(first + 1);
            }
        }

        createBuffersVINT(sphere, vertexPositionData, indexData, normalData, textureCoordData);
        // On copie les autres données
        sphere.position = parPosition;
        sphere.colorVal = parColorVal;

        return sphere;

    }

    function createQuad(parP1, parP2, parP3, parP4, parColorVal)
    {
        // Données de sphere
        var plan = [];
        // Données  attribute
        var vertexPositionData = [];
        var normalData = [];
        var textureCoordData = [];

        // Pour chacun des somemts
        vertexPositionData.push(parP1[0]);
        vertexPositionData.push(parP1[1]);
        vertexPositionData.push(parP1[2]);

        vertexPositionData.push(parP2[0]);
        vertexPositionData.push(parP2[1]);
        vertexPositionData.push(parP2[2]);

        vertexPositionData.push(parP3[0]);
        vertexPositionData.push(parP3[1]);
        vertexPositionData.push(parP3[2]);

        vertexPositionData.push(parP4[0]);
        vertexPositionData.push(parP4[1]);
        vertexPositionData.push(parP4[2]);


        textureCoordData.push(0);
        textureCoordData.push(0);

        textureCoordData.push(1);
        textureCoordData.push(0);

        textureCoordData.push(0);
        textureCoordData.push(1);

        textureCoordData.push(1);
        textureCoordData.push(1);   

        var norm1 = computeNormal(parP1, parP3, parP2); 
        var norm2 = computeNormal(parP2, parP1, parP3); 
        var norm3 = computeNormal(parP3, parP4, parP2); 
        var norm4 = computeNormal(parP4, parP2, parP3); 

        normalData.push(norm1[0]);
        normalData.push(norm1[1]);
        normalData.push(norm1[2]);

        normalData.push(norm2[0]);
        normalData.push(norm2[1]);
        normalData.push(norm2[2]);

        normalData.push(norm3[0]);
        normalData.push(norm3[1]);
        normalData.push(norm3[2]);

        normalData.push(norm4[0]);
        normalData.push(norm4[1]);
        normalData.push(norm4[2]);

        // Tableau d'indexes
        var indexData = [];
        indexData.push(0);
        indexData.push(1);
        indexData.push(2);
        indexData.push(1);
        indexData.push(2);
        indexData.push(3);


        createBuffersVINT(plan, vertexPositionData, indexData, normalData, textureCoordData);
        // On copie les autres données
        plan.position = [0,0,0];
        plan.colorVal = parColorVal;

        return plan;

    }

    function createScene() 
    {
        // On crée les sphères
        var sphereOne = createSphere(10,[-50, -10, -100], [0.3, 0.5, 0.75],100);
        sphereOne.shaderProgram = generateProgram("basicVertex", "basicFragment");
        sphereOne.modelMatrix = mat4.create();
        mat4.identity(sphereOne.modelMatrix);
        mat4.translate(sphereOne.modelMatrix,sphereOne.position);
        initShaderData(sphereOne.shaderProgram, sphereOne);
        sphereOne.isOutDated = true;

        sceneObjects.push(sphereOne);
        
        
        // // On crée les sphères
        var sphereTwo = createSphere(10,[100, -10, 100], [1.0, 0.5, 0.75],100);
        sphereTwo.shaderProgram = generateProgram("basicVertex", "basicFragment");
        sphereTwo.modelMatrix = mat4.create();
        mat4.identity(sphereTwo.modelMatrix);
        mat4.translate(sphereTwo.modelMatrix,sphereTwo.position);
        initShaderData(sphereTwo.shaderProgram, sphereTwo);
        sphereTwo.isOutDated = true;

        sceneObjects.push(sphereTwo);
        
    
        // // On crée les sphères
        var plan = createQuad([-100, -20, -400], [400, -20, -400], [-100, -20, 400], [400, -20, 400],  [1.0, 1.0, 0.75]);
        plan.shaderProgram = generateProgram("basicVertex", "basicFragment");
        plan.modelMatrix = mat4.create();
        mat4.identity(plan.modelMatrix);
        mat4.translate(plan.modelMatrix,plan.position);
        initShaderData(plan.shaderProgram, plan);
        plan.isOutDated = true;

        sceneObjects.push(plan);

    }
    function drawObject(parObj)
    {
        // ON bind le pos buffer 
        gl.enableVertexAttribArray(parObj.shaderProgram.vertexPositionAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, parObj.vertexPositionBuffer);
        gl.vertexAttribPointer(parObj.shaderProgram.vertexPositionAttribute, parObj.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        // ON bind le normal buffer 
        gl.enableVertexAttribArray(parObj.shaderProgram.vertexNormalAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, parObj.vertexNormalBuffer);
        gl.vertexAttribPointer(parObj.shaderProgram.vertexNormalAttribute, parObj.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0); 

        // ON bind le texcoord buffer 
        gl.enableVertexAttribArray(parObj.shaderProgram.vertexTexCoordAttribute);
        gl.bindBuffer(gl.ARRAY_BUFFER, parObj.vertexTextureCoordBuffer);
        gl.vertexAttribPointer(parObj.shaderProgram.vertexTexCoordAttribute, parObj.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);                

        // On bind l'IBO
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, parObj.vertexIndexBuffer);
        // On injecte les données spécifique à la sphère
        injectSpecificUniforms(parObj) 
        // On déssine la sphère
        gl.drawElements(gl.TRIANGLES, parObj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        gl.disableVertexAttribArray(parObj.shaderProgram.vertexPositionAttribute);
        gl.disableVertexAttribArray(parObj.shaderProgram.vertexNormalAttribute);
        gl.disableVertexAttribArray(parObj.shaderProgram.vertexTexCoordAttribute);

    }

    function drawScene() 
    {
        // On définie le viewport
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        // On injecte les données communes
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        for(var i = 0; i < sceneObjects.length;++i)
        {
            bindProgram(sceneObjects[i].shaderProgram);
            injectGenericUniforms(sceneObjects[i].shaderProgram);
            drawObject(sceneObjects[i]);
            unbindProgram();
        }    
        if(camera.isOutDated)
        {
            camera.isOutDated = false;
        }
    }

    function initRender()
    {
        isRendering = true;
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.enable(gl.DEPTH_TEST);
    }


    function renderLoop()
    {
        window.requestAnimFrame(renderLoop);
        drawScene();        
    }
    function main() 
    {
        // Récupération du canvas
        canvas = document.getElementById("canvas");

        // Initialisation du contexte WebGL
        initGL(canvas);

        // Initialisation de la camera
        initCamera();

        // Initialisation de la scene
        createScene();

        initRender();
        renderLoop();


    }

</script>
</head>

<body onload="main();">
    <canvas id="canvas" style="border: none;" width="1280" height="720"></canvas>
</body>

</html>
